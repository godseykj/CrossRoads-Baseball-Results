---
title: "Crossroads Baseball Project Results."
author: "Levi Cain, Kara Godsey, and Dr. Ryan Johnson"
date: "4/22/2020"
output:
  rmdformats::readthedown:
    #highlight: kate
---


```{r setup, echo=FALSE, cache=FALSE}
suppressWarnings(library(knitr))
suppressWarnings(library(rmdformats))
suppressWarnings(library(kableExtra))
suppressWarnings(library(ggplot2))

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


# Welcome
Welcome to the results page of our student research project.  On this site you will find the top hitters in the conference, projections for upcoming games, as well as a searchable table containing stats for all hitters in the Crossroads League.

---


```{r}
suppressWarnings(library(rvest))
```


```{r teams-and-urls}
teams <- c("BC","GOC","GRC","HU","INWU","MAR","MVNU","SAU","SFIN","TAYL")
names(teams) <- c(1629, 1678, 1679, 1688, 1694, 1717, 1736, 1780, 1805, 1784)
urls <- paste0("http://www.dakstats.com/WebSync/Pages/Team/IndividualStats.aspx?association=10&sg=MBA&conference=NAIMBA1_CROSS&team=",names(teams),"&sea=NAIMBA_2019")
```

```{r retrieval-functions}
get_batting <- function(url) {
  bpf <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[37]] %>%
    html_table(fill = TRUE)
}

get_pitching <- function(url) {
  bpf <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[38]] %>%
    html_table(fill = TRUE)
}

get_fielding <- function(url) {
  bpf <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[39]] %>%
    html_table(fill = TRUE)
}
```


```{r lapply-it}
batting <- lapply(urls, get_batting)
names(batting) <- teams
pitching <- lapply(urls, get_pitching)
names(pitching) <- teams
fielding <- lapply(urls, get_fielding)
names(fielding) <- teams
```

```{r}
baseball <- list(batting, pitching, fielding)
names(baseball) <- c("Batting", "Pitching", "Fielding")
```

```{r writeit}
#A function to write the data to csv files
writeit <- function(x) {
  #Batting
  write.csv(batting[[x]], file = paste0("Data/Batting", "/", x, ".csv"))
  #Pitching
  write.csv(pitching[[x]], file = paste0("Data/Pitching", "/", x, ".csv"))
  #Fielding
  write.csv(fielding[[x]], file = paste0("Data/Fielding", "/", x, ".csv"))
}
```

```{r write-to-csv}
invisible(lapply(teams, writeit))
```

```{r saved}
save(baseball, file = "Data/stats_by_type.Rdata")
```


```{r schedule_scrape}
library(rvest)


teams <- c("BC","GOC","GRC","HU","INWU","MAR","MVNU","SAU","SFIN","TAYL")
#R lets us rename the indices of vectors.
names(teams) <- c(1629, 1678, 1679, 1688, 1694, 1717, 1736, 1780, 1805, 1784)
  p_effects <- paste0("http://www.dakstats.com/WebSync/Pages/Team/TeamSchedule.aspx?association=10&sg=MBA&sea=NAIMBA_2019&team=", names(teams))
  
  #Function to get schedule of each team and remove blank rows
  
  get_schedule <- function(url){
  tbls_effects <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[36] %>%
    html_table(fill = TRUE)
  Team_Schedule <- data.frame(tbls_effects[[1]])
  Team_Schedule <- Team_Schedule[!apply(is.na(Team_Schedule) | Team_Schedule == "", 1, all),]
  }
  
  schedule <- lapply(p_effects, get_schedule)
  names(schedule) <- teams
```

```{r Park_Factor function}
  Park_effects <- function(g){
    
    Team_Schedule <- schedule[[g]]
    Sched <- Team_Schedule["X2"]
    Scores <- c()
    Conf_Games <- data.frame(Date=character(),
                             Opponent=character(), 
                             Location=character(),
                             Score=character(),
                             Result=character(),
                             stringsAsFactors=FALSE) 
    j=1
    for (i in 1:nrow(Sched)){
    
      if (grepl("*", Sched[[1]][[i]], fixed = TRUE) == TRUE){
        Conf_Games[j,] <- Team_Schedule[i,]
        j = j + 1
      } 
    }
    
    #print(Conf_Games)
    
    #Separate Home games from neutral and away games
    Home_Games <- data.frame(Date=character(),
                             Opponent=character(), 
                             Location=character(),
                             Score=character(),
                             Result=character(),
                             stringsAsFactors=FALSE)
    
    Away_Games <- data.frame(Date=character(),
                             Opponent=character(), 
                             Location=character(),
                             Score=character(),
                             Result=character(),
                             stringsAsFactors=FALSE)
    
    
    Loc <- Conf_Games["Location"]
  
    w=1
    z=1
    for (k in 1:nrow(Loc)){
      if (is.element("H", Loc[[1]][[k]]) == TRUE){
        Home_Games[w,] <- Conf_Games[k,]
        w = w + 1
      }
      else if (is.element("A", Loc[[1]][[k]]) == TRUE){
        Away_Games[z,] <- Conf_Games[k,]
        z = z + 1
      }
     
    }
    
    #Put Home team score for each game into a vector
      
  
      Scores_H <- Home_Games[["Score"]]
      Scores_A <- Away_Games[["Score"]]
      p=1
      q=1
      c=1
      d=1
      
        Team_Runs_A <- c()
        Team_Runs_H <- c()
        Opp_Runs_H <- c()
        Opp_Runs_A <- c()
        
        for (x in Scores_H){
          
          if (grepl("(", x, fixed = TRUE) == TRUE){
            Opp_Runs_H[d] <- as.integer(substr(x, (regexpr(pattern ='-', x)+1), nchar(x)-4))
            Team_Runs_H[p] <- as.integer(substr(x, 1, (regexpr(pattern ='-', x)-1)))
          }
          else{
            Team_Runs_H[p] <- as.integer(substr(x, 1, (regexpr(pattern ='-', x)-1)))
            Opp_Runs_H[d] <- as.integer(substr(x, (regexpr(pattern ='-', x)+1), nchar(x)))
            
          }
          
          p = p + 1
          d = d + 1
        }
        
        for (r in Scores_A){
          if (grepl("(", r, fixed = TRUE) == TRUE){
            
            Opp_Runs_A[c] <- as.integer(substr(r, (regexpr(pattern ='-', r)+1), nchar(r)-4))
            Team_Runs_A[q] <- as.integer(substr(r, 1, (regexpr(pattern ='-', r)-1)))
            
          }
          else{
            
            Team_Runs_A[q] <- as.integer(substr(r, 1, (regexpr(pattern ='-', r)-1)))
            Opp_Runs_A[c] <- as.integer(substr(r, (regexpr(pattern ='-', r)+1), nchar(r)))
            
          }
          q = q + 1
          c = c + 1
          
        }
       
  
  Park_effect <- ((sum(Team_Runs_H)+sum(Opp_Runs_H))/length(Team_Runs_H))/((sum(Team_Runs_A)+sum(Opp_Runs_A))/length(Team_Runs_A))
      
  }
  
  p_factor <- teams %>%
    lapply(Park_effects)
  names(p_factor) <- teams
```


```{r}
load("Data/stats_by_type.Rdata")
Batting <- baseball[["Batting"]]
teams <- names(Batting)
```


```{r}
bat_stats <- function(y){
  x <- Batting[[y]]
  #Caught Stealing
  x$CS <- x$SBA - x$SB
  #Singles
  x$X1B <- x$H - x[,8] - x[,9] - x$HR
  #Runs Created
  x$RC <- round((x$H + x$BB)*x$TB/(x$AB + x$BB),2)
  #OPS
  x$OPS <- x$OB + x$SLG
  #POP
  x$POP <- x$OPS + x$AVG
  #Total Average
  x$TA <- round((x$TB + x$BB + x$HBP + x$SB)/(x$AB - x$H + x$SH + x$SF + x$CS + x$GDP), 3)
  #Plate Appearances
  x$PA <- x$AB+x$BB+x$HBP+x$SF
  #Batting Average on Balls in Play
  x$BABIP <- round((x$H - x$HR)/(x$AB - x$SO - x$HR + x$SF),3)
  #Hoban Efficiency Quotient - offense
  x$HEQO <- x$TB + x$R + x$RBI + x$SB + (0.5*x$BB)
  #Base Stealing Runs
  x$Steal_Runs <- round(((x$H + x$BB - x$CS)*(x$TB + (0.7 * x$SB)))/(x$AB + x$BB + x$CS),2)
  x
}
```

```{r lapplyit}
Batting <- teams %>%
  lapply(bat_stats)
names(Batting) <- teams
```

```{r}
batting_stats <- c("H","AB","BB","HBP","SF","TB", "2B","3B","HR","X1B","R")
CL_Avg_B <- c()
All_stats_batting <- c()
w = 0

for (n in batting_stats){
  
  for (j in teams){
    
    P <- Batting[[j]]#as.data.frame(read.csv(paste("Data/Batting/",j,".csv",sep="")))
    
    col_num =  which( colnames(P)==n )
    for (k in seq(length(P[[n]]))){ 
      
      All_stats_batting[w+k] <- P[,col_num][k]
      #print(All_stats)
    }
    
    w  = k + w
    
  }
  CL_Avg_B[n] <- sum(All_stats_batting)
  All_stats_batting <- c()
  w = 0
}

#print(CL_Avg_B)
```

```{r}
CL_OBP <- (CL_Avg_B[[1]]+CL_Avg_B[[3]]+CL_Avg_B[[4]])/(CL_Avg_B[[2]]+CL_Avg_B[[3]]+CL_Avg_B[[4]]+CL_Avg_B[[5]])
CL_SLG <- (CL_Avg_B[[6]])/(CL_Avg_B[[2]])
CL_wOBA <- ((.69)*(CL_Avg_B[["BB"]])+(.72)*(CL_Avg_B[["HBP"]])+(.89)*(CL_Avg_B[["X1B"]])+(1.27)*(CL_Avg_B[["2B"]])+(1.62)*(CL_Avg_B[["3B"]])+(2.10)*(CL_Avg_B[["HR"]]))/(CL_Avg_B[["AB"]]+CL_Avg_B[["BB"]]+CL_Avg_B[["SF"]]+CL_Avg_B[["HBP"]])
CL_PA <- CL_Avg_B[["AB"]]+CL_Avg_B[["BB"]]+CL_Avg_B[["HBP"]]+CL_Avg_B[["SF"]] 
CL_R_per_PA <- CL_Avg_B[["R"]]/CL_PA
CL_wRC <- CL_Avg_B[["R"]]
CL_wRC_per_PA <- CL_R_per_PA

#League adjustment for Batting Runs
ABF <- ((0.47 * CL_Avg_B[["X1B"]]) + (0.38*CL_Avg_B[["2B"]]) + (0.55*CL_Avg_B[["3B"]]) + (0.93*CL_Avg_B[["HR"]]) +(0.33*(CL_Avg_B[["BB"]]+CL_Avg_B[["HBP"]]))/(CL_Avg_B[["AB"]]-CL_Avg_B[["H"]]))

```

```{r}
bat_stats2 <- function(y){
  x <- Batting[[y]]
  #OPS+
  x$OPS_plus <- round((100)*(((x$OB/CL_OBP)+(x$SLG/CL_SLG))-1),2)
  #weighted On-Base Average
  x$wOBA <- round(((.69)*(x$BB)+(.72)*(x$HBP)+(.89)*(x$X1B)+(1.27)*(x[["2B"]])+(1.62)*(x[["3B"]])+(2.10)*(x$HR))/(x$AB+x$BB+x$SF+x$HBP),3)
  #Batting Runs
  x$Bat_Runs <- round(((0.47*x$X1B) + (0.38*x[["2B"]]) + (0.55*x[["3B"]]) + (0.93*x$HR) + ((0.33)*x$BB + x$HBP)/(ABF *(x$AB - x$H))),2)
  #weighted Runs Above Average
  x$wRAA <- round(((x$wOBA-CL_wOBA)/(1.157))*(x$PA),3)
  #weighted Runs Created
  x$wRC <- round(x$wRAA + (x$PA)*((CL_Avg_B[["R"]])/(CL_PA)),2)
  x$wRC_plus <- round((100)*((((x$wRAA/x$PA)+CL_R_per_PA)+(CL_R_per_PA-(p_factor[[y]])*(CL_R_per_PA)))/(CL_wRC_per_PA)),2)
  x
}
```

```{r lapply}
Batting <- teams %>%
  lapply(bat_stats2)
names(Batting) <- teams
```


---

# Top Hitters in the Crossroads League

After compiling advanced batting statistics for each team, we chose to use weighted runs created plus (wRC+) in order to evaluate a hitter's overall contribution to the team. This statistic takes the park factor into account. Additionally, it adjusts based on a player's performance in comparison to the league average.

```{r echo=FALSE}
Best_Players <- data.frame(wRC_plus=numeric())
```

```{r best_players_calc}
#counter for teams
y = 1


for (x in Batting){
  
  wRC_plus <- c()
  wRC_name <- c()
  wRC_team <- c()
  PA <- c()
  wRC_plus <- x[["wRC_plus"]]
  wRC_name <- x[["Batting"]]
  PA <- x[["PA"]]
  team <- teams[y]
  for (z in wRC_name){
  
  wRC_team <- c(wRC_team, team[z])      
  
  
  }
  
  new.Best_Players <- data.frame(team, wRC_name,  wRC_plus,  PA)
  Best_Players <- rbind(Best_Players, new.Best_Players)
  
  y = y + 1
}
```

```{r remove_values}
#remove NaN values
Best_Players <- Best_Players[complete.cases(Best_Players), ]

#remove Total and Opponents values
Best_Players <- Best_Players[ !(Best_Players$wRC_name %in% c("Opponents:", "Total:")), ]

Best_Players <- Best_Players[order(-Best_Players$wRC_plus),]

#require players to have at least 20 plate appearances
Best_Players <- Best_Players[!(Best_Players$PA < 20),]

```

## Top 10 Hitters

The following is a list of the top 10 hitters in the Crossroads League in 2019.

```{r echo=FALSE}
Best_Players$wRC_plus <- round(Best_Players$wRC_plus, 2)
kable(Best_Players[1:10, 1:4], row.names = FALSE, col.names=c("Team", "Player", "wRC+", "PA")) %>%
  kable_styling(bootstrap_options = c("striped", "bordered"), full_width = FALSE) %>%
    footnote(general = "*min. 20 plate appearances", general_title = "")
```

```{r schedules}
library(rvest)
library(stringr)
library(tidyverse)

#2019 schedules

load("Data/stats_by_type.Rdata")
Batting <- baseball[["Batting"]]
Pitching <- baseball[["Pitching"]]
Fielding <- baseball[["Fielding"]]
teams <- names(Batting)

#General info
teams <- c("BC","GOC","GRC","HU","INWU","MAR","MVNU","SAU","SFIN","TAYL")
names(teams) <- c(1629, 1678, 1679, 1688, 1694, 1717, 1736, 1780, 1805, 1784) 

#get schedules from dakstats
schedule_urls <- paste0("http://www.dakstats.com/WebSync/Pages/Team/TeamSchedule.aspx?association=10&sg=MBA&sea=NAIMBA_2019&team=",names(teams))
#View(schedule_urls)

#function to get the schedule of a team
get_schedule <- function(schedule_urls) {
  bpf <- schedule_urls %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[36]] %>%
    html_table(fill = TRUE)
}

#p_effects_urls <- teams %>%
  #lapply(get_schedule)
#names(p_effects_urls) <- teams

schedules <- lapply(schedule_urls, get_schedule)
names(schedules) <- teams
#View(schedules)

#A function to clean up the tables and show only conference schedule
conference <- function(x){
  #Gets rid of rows containing only NA
  schedules[[x]] <- schedules[[x]][!apply(is.na(schedules[[x]]) | schedules[[x]] == "", 1, all),]
  #Rename columns
  names(schedules[[x]])[1] <- "Date"
  names(schedules[[x]])[2] <- "Opponent"
  names(schedules[[x]])[3] <- "Location"
  names(schedules[[x]])[4] <- "Score"
  names(schedules[[x]])[5] <- "Decision"
  #Grab only the conference games
  CL_schedule <- schedules[[x]] %>%
    filter(str_detect(Opponent, "\\*"))
  #remove column with only NA at the end
  CL_schedule <- CL_schedule[-6]
  #separate score into home and away columns
  CL_schedule <- CL_schedule %>%
    separate(Score, c("Team_Score","Opp_Score"),"-")
  #output only the CL schedules
  schedules[[x]] <- CL_schedule
  schedules[[x]] <- schedules[[x]] %>%
    mutate(Team = x)
}

schedules <- lapply(teams, conference)
names(schedules) <- teams

schedules_19 <- schedules
```


```{r echo=FALSE}
#A function to write the data to csv files
writeit <- function(x) {
  write.csv(schedules[[x]], file = paste0("Data/Schedules/2019", "/", x, ".csv"))
}

#Write to csv
#lapply(teams, writeit)
```


```{r sched-20}
#2020 schedules

load("Data/stats_by_type.Rdata")
Batting <- baseball[["Batting"]]
Pitching <- baseball[["Pitching"]]
Fielding <- baseball[["Fielding"]]
teams <- names(Batting)

#General info
teams <- c("BC","GOC","GRC","HU","INWU","MAR","MVNU","SAU","SFIN","TAYL")
names(teams) <- c(1629, 1678, 1679, 1688, 1694, 1717, 1736, 1780, 1805, 1784) 

#get schedules from dakstats
schedule_urls <- paste0("http://www.dakstats.com/WebSync/Pages/Team/TeamSchedule.aspx?association=10&sg=MBA&sea=NAIMBA_2020&team=",names(teams))
#View(schedule_urls)

#function to get the schedule of a team
get_schedule <- function(schedule_urls) {
  bpf <- schedule_urls %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[36]] %>%
    html_table(fill = TRUE)
}

#p_effects_urls <- teams %>%
#lapply(get_schedule)
#names(p_effects_urls) <- teams

schedules <- lapply(schedule_urls, get_schedule)
names(schedules) <- teams
#View(schedules)

#A function to clean up the tables and show only conference schedule
conference <- function(x){
  #Gets rid of rows containing only NA
  schedules[[x]] <- schedules[[x]][!apply(is.na(schedules[[x]]) | schedules[[x]] == "", 1, all),]
  #Rename columns
  names(schedules[[x]])[1] <- "Date"
  names(schedules[[x]])[2] <- "Opponent"
  names(schedules[[x]])[3] <- "Location"
  names(schedules[[x]])[4] <- "Score"
  names(schedules[[x]])[5] <- "Decision"
  #Grab only the conference games
  CL_schedule <- schedules[[x]] %>%
    filter(str_detect(Opponent, "\\*"))
  #remove column with only NA at the end
  CL_schedule <- CL_schedule[-6]
  #separate score into home and away columns
  CL_schedule <- CL_schedule %>%
    separate(Score, c("Team_Score","Opp_Score"),"-")
  #output only the CL schedules
  schedules[[x]] <- CL_schedule
  schedules[[x]] <- schedules[[x]] %>%
    mutate(Team = x)
}

schedules <- lapply(teams, conference)
names(schedules) <- teams

schedules_20 <- schedules
```


```{r echo=FALSE}
#A function to write the data to csv files
writeit <- function(x) {
  write.csv(schedules[[x]], file = paste0("Data/Schedules/2020", "/", x, ".csv"))
}

#Write to csv
#lapply(teams, writeit)
```

```{r elo_initial}
library(tidyverse)
library(elo)

#place to store each team's elo rating
ratings <- data.frame(team = teams)
ratings <- ratings %>%
  mutate(elo = 1500)
#View(ratings)

#function that adds a binary variable
#1 if home wins/away loses and 0 if home loses/away wins
add_elo_score <- function(x){
  schedules_19[[x]] <- schedules_19[[x]] %>%
    mutate(result = ifelse(grepl("W",Decision,fixed=TRUE)&grepl("H",Location,fixed=TRUE),1,ifelse(grepl("A",Location,fixed=TRUE)&grepl("L",Decision, fixed=TRUE),1,0)))
  #change opponent name to match abbreviations
  schedules_19[[x]] <- schedules_19[[x]] %>%
    mutate(Opp = ifelse(grepl("Bethel (Ind.) *",Opponent,fixed=TRUE),teams[1],ifelse(grepl("Goshen (Ind.) *",Opponent,fixed=TRUE),teams[2],ifelse(grepl("Grace (Ind.) *",Opponent,fixed=TRUE),teams[3],ifelse(grepl("Huntington (Ind.) *",Opponent,fixed=TRUE),teams[4],ifelse(grepl("Indiana Wesleyan *",Opponent,fixed=TRUE),teams[5],ifelse(grepl("Marian (Ind.) *",Opponent,fixed=TRUE),teams[6],ifelse(grepl("Mount Vernon Nazarene (Ohio) *",Opponent,fixed=TRUE),teams[7],ifelse(grepl("Spring Arbor (Mich.) *",Opponent,fixed=TRUE),teams[8],ifelse(grepl("St. Francis (Ind.) *",Opponent,fixed=TRUE),teams[9],teams[10]))))))))))
}

schedules_19 <- lapply(teams, add_elo_score)
names(schedules_19) <- teams
```

```{r end_elos}
#creating a master schedule with all games
AllGames <- do.call("rbind",schedules_19)
HomeGames <- AllGames %>%
  dplyr::filter(str_detect(Location, "H"))
#View(HomeGames)


#Fix extra innings issue
Opp <- HomeGames[["Opp_Score"]]

for (x in seq(length(Opp))){
  if (grepl("(", Opp[x], fixed = TRUE) == TRUE){
     Opp[x] <- as.integer(substr(Opp[x], 1, nchar(Opp[x])-4))
    
    }
}

HomeGames[["Opp_Score"]] <- Opp

#Add margin of victory column

HomeGames$Team_Score <- as.integer(HomeGames$Team_Score)
HomeGames$Opp_Score <- as.integer(HomeGames$Opp_Score)

HomeGames$Vict_Margin <- (HomeGames$Team_Score - HomeGames$Opp_Score)

#Way to run elo that includes margin of victory using log

#Run elo
e <- elo.run(score(HomeGames[["Team_Score"]], HomeGames[["Opp_Score"]]) ~ HomeGames$Team + HomeGames$Opp +
               k(20*log(abs(HomeGames[["Team_Score"]] - HomeGames[["Opp_Score"]]) + 1)), data = HomeGames)


#print results
f <- final.elos(e)
f <- sort(f,decreasing = TRUE)

```

```{r}
#regress elo values to the mean
for (g in 1:length(f)){

   f[g] <- f[g] * (2/3) + 500
  
}

#View(f)
```

---

# Upcoming Games

```{r}
update_web <- function(team1, team2, game_loc){
  
  team1_elo <- f[team1]
  team2_elo <- f[team2]
  #print(team1_elo)
  #print(team2_elo)
  game_prob_team1win <- elo.prob(team1_elo, team2_elo)
  game_prob_team2win <- elo.prob(team2_elo, team1_elo)
  
  print(game_prob_team1win)
  print(game_prob_team2win)
  game_park_effect <- p_factor[game_loc]
  print(game_park_effect)
  
  elos <- c(f[team1], f[team2])
  teams <- names(elos)
  elo_data = data.frame(teams, elos)
  elo_data <- elo_data %>% 
    mutate(Game = paste0(teams[1], " vs ", teams[2])) %>%
    mutate(elo_label = paste0(teams, " has elo score of ", round(elos)))
  ggplot(elo_data, aes(x = teams, y = elos, fill = teams)) +
    geom_col() +
    geom_text(aes(label = elo_label), position = position_stack(vjust = 0.5)) +
    scale_fill_brewer(palette = "Set2")
  
  #The format below will work well once you have perent chance of winning
  
  #ggplot(elo_data, aes(x = Game, y = elos, fill = teams)) +
  #  geom_col() +
  #  geom_text(aes(label = elo_label), position = position_stack(vjust = 0.5)) +
  #  scale_fill_brewer(palette = "Set2")
  
}
```

The next game is Indiana Wesleyan vs. Grace at Grace.
```{r}
update_web("INWU", "GRC", "GRC")
```

---